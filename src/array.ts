/**
 * An extended Array class providing convenient getters and powerful utility methods.
 * It's fully generic, type-safe, and designed for seamless method chaining.
 *
 * @template T The type of elements in the array. Defaults to `unknown`.
 */
export class ArraySL<T = unknown> extends Array<T> {
    /**
     * Ensures that methods inherited from Array (like .map, .filter, .slice)
     * return an instance of ArraySL instead of a plain Array. This makes
     * method chaining seamless.
     */
    static get [Symbol.species](): ArrayConstructor {
        return this as unknown as ArrayConstructor;
    }

    /**
     * Creates a new ArraySL instance. This constructor is compatible with the
     * standard Array constructor signatures.
     */
    constructor(item?: Iterable<T> | number) {
        // This logic handles the different ways an Array can be constructed.
        // 1. new ArraySL(5) -> called by .map() etc., creates an empty array of length 5.
        // 2. new ArraySL(item1, item2) -> creates an array with the given items.
        if (ArraySL.isArray(item)) {
            super(...item);
        } else {
            super(item as number);
        }
    }

    /**
     * Returns the first element of the array.
     * @returns {T | undefined} The first element, or `undefined` if the array is empty.
     */
    get first(): T | undefined {
        return this[0];
    }

    /**
     * Returns the last element of the array.
     * @returns {T | undefined} The last element, or `undefined` if the array is empty.
     */
    get last(): T | undefined {
        return this[this.length - 1];
    }

    /**
     * Returns a random element from the array.
     * @returns {T | undefined} A random element, or `undefined` if the array is empty.
     */
    get random(): T | undefined {
        if (this.length === 0) {
            return undefined;
        }
        return this[Math.floor(Math.random() * this.length)];
    }

    /**
     * Returns a new ArraySL containing only the unique elements from the original array,
     * based on a key generated by the provided function. This method is highly performant (O(n)).
     *
     * @param accessor A function that takes an element and returns a primitive value
     *   (string, number) to be used as the key for uniqueness checks.
     * @returns {ArraySL<T>} A new ArraySL instance with duplicate elements removed.
     */
    unique(accessor: (item: T) => string | number): ArraySL<T> {
        const seen = new Set<string | number>();
        return this.filter((item) => {
            const key = accessor(item);
            if (seen.has(key)) {
                return false;
            }
            seen.add(key);
            return true;
        }) as ArraySL<T>;
    }

    /**
     * Finds the median item(s) of the array based on a numeric property.
     * The median is the middle item in a sorted set.
     *
     * @param by A function to extract a number from an item for sorting.
     * @returns {ArraySL<T>} A new ArraySL containing the median item. If the array
     *   has an even number of elements, it returns the two middle items. Returns
     *   an empty array if no valid items are found.
     * @example
     * const products = new ArraySL([
     *   { name: 'A', price: 10 },
     *   { name: 'B', price: 30 },
     *   { name: 'C', price: 20 }
     * ]);
     * console.log(products.median(p => p.price)); // ArraySL [{ name: 'C', price: 20 }]
     *
     * // Even number of items returns the two middle items
     * const even = products.slice(0, 2); // prices 10 and 30
     * console.log(even.median(p => p.price)); // ArraySL [{ name: 'A', price: 10 }, { name: 'B', price: 30 }]
     */
    median(by: (item: T) => number): ArraySL<T> {
        if (this.length === 0) {
            return new ArraySL<T>();
        }

        // Create a shallow copy to avoid mutating the original array
        const sorted = this.slice().sort((a, b) => by(a) - by(b));

        const mid = Math.floor(sorted.length / 2);

        if (sorted.length % 2 !== 0) {
            // Odd length: return the single middle item
            return new ArraySL<T>([sorted[mid]]);
        } else {
            // Even length: return the two middle items
            return new ArraySL<T>([sorted[mid - 1], sorted[mid]]);
        }
    }

    /**
     * Finds the most frequently occurring item(s) in the array (the mode).
     *
     * @param by A function to extract a comparable key from an item.
     * @returns {ArraySL<T>} A new ArraySL containing the most frequent item(s).
     *   Returns an empty array if there is no unique mode.
     * @example
     * const users = new ArraySL([
     *   { name: 'Alice', city: 'Paris' },
     *   { name: 'Bob', city: 'Tokyo' },
     *   { name: 'Charlie', city: 'Paris' }
     * ]);
     * console.log(users.mode(u => u.city)); // ArraySL [{ name: 'Alice', city: 'Paris' }, { name: 'Charlie', city: 'Paris' }]
     */
    mode(by: (item: T) => any): ArraySL<T> {
        if (this.length === 0) {
            return new ArraySL<T>();
        }

        const frequencies = new Map<any, number>();
        let maxFreq = 0;

        for (const item of this) {
            const key = by(item);
            const newCount = (frequencies.get(key) || 0) + 1;
            frequencies.set(key, newCount);
            if (newCount > maxFreq) {
                maxFreq = newCount;
            }
        }

        // No unique mode if all items appear with the same frequency (e.g., [1, 2, 3] or [1,1,2,2])
        if (maxFreq <= 1 && this.length > 1) {
            return new ArraySL<T>();
        }

        const modeKeys = new Set<any>();
        for (const [key, freq] of frequencies.entries()) {
            if (freq === maxFreq) {
                modeKeys.add(key);
            }
        }

        // Handle case where all items are modes (e.g., [1,1,2,2])
        if (modeKeys.size > 1 && (modeKeys.size * maxFreq) === this.length) {
            return new ArraySL<T>();
        }

        return this.filter((item) => modeKeys.has(by(item))) as ArraySL<T>;
    }
}
