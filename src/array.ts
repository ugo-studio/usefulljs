/**
 * An extended Array class providing convenient getters and powerful utility methods.
 * It's fully generic, type-safe, and designed for seamless method chaining.
 *
 * @template T The type of elements in the array. Defaults to `unknown`.
 */
export class ArraySL<T = unknown> extends Array<T> {
    /**
     * Ensures that methods inherited from Array (like .map, .filter, .slice)
     * return an instance of ArraySL instead of a plain Array. This makes
     * method chaining seamless.
     */
    static get [Symbol.species](): ArrayConstructor {
        return this as unknown as ArrayConstructor;
    }

    /**
     * Creates a new ArraySL instance. This constructor is compatible with the
     * standard Array constructor signatures.
     */
    constructor(item?: Iterable<T> | number) {
        // This logic handles the different ways an Array can be constructed.
        // 1. new ArraySL(5) -> called by .map() etc., creates an empty array of length 5.
        // 2. new ArraySL(item1, item2) -> creates an array with the given items.
        if (ArraySL.isArray(item)) {
            super(...item);
        } else if (typeof item === "number") {
            super(item as number);
        } else super();
    }

    /**
     * Returns the first element of the array.
     * @returns {T | undefined} The first element, or `undefined` if the array is empty.
     */
    get first(): T | undefined {
        return this[0];
    }

    /**
     * Returns the last element of the array.
     * @returns {T | undefined} The last element, or `undefined` if the array is empty.
     */
    get last(): T | undefined {
        return this[this.length - 1];
    }

    /**
     * Returns a random element from the array.
     * @returns {T | undefined} A random element, or `undefined` if the array is empty.
     */
    get random(): T | undefined {
        if (this.length === 0) {
            return undefined;
        }
        return this[Math.floor(Math.random() * this.length)];
    }

    /**
     * Returns a new ArraySL containing only the unique elements from the original array.
     * Uniqueness is based on the element itself or on a key generated by the provided accessor.
     * This method is highly performant (O(n)).
     *
     * @param options An optional configuration object.
     *   - `accessor`: An optional function that takes an element and returns a value to be used
     *     for the uniqueness check. If not provided, the element itself is used. Keys that are
     *     objects or arrays are compared by their JSON string representation.
     * @returns {ArraySL<T>} A new ArraySL instance with duplicate elements removed.
     */
    unique(options: {
        accessor?: (item: T) => any;
    } = {}): ArraySL<T> {
        const { accessor = (item: T) => item } = options;
        const seen = new Set<any>();
        return this.filter((item) => {
            const key = accessor(item);
            if (seen.has(key)) {
                return false;
            }
            seen.add(key);
            return true;
        }) as ArraySL<T>;
    }

    /**
     * Returns a new ArraySL containing duplicate elements from the original array.
     * This method is highly configurable and performant, operating in a single pass (O(n)).
     *
     * @param options An optional configuration object.
     *   - `accessor`: An optional function that takes an element and returns a value to be used
     *     for the uniqueness check. If not provided, the element itself is used. Keys that are
     *     objects or arrays are compared by their JSON string representation.
     *   - `mode`: Determines which duplicate items to include in the result.
     *      - 'all' (default): Returns all instances of items that are duplicates.
     *      - 'first': Returns only the first instance of each duplicated item.
     *      - 'subsequent': Returns only the duplicate instances that appear after the first one.
     * @returns {ArraySL<T>} A new ArraySL instance containing the specified duplicate elements.
     */
    duplicates(options: {
        accessor?: (item: T) => any;
        mode?: "first" | "subsequent" | "all";
    } = {}): ArraySL<T> {
        const { mode = "all", accessor = (item: T) => item } = options;
        const result = new ArraySL<T>();

        // The map tracks the state of each key using a dedicated object.
        const seen = new Map<any, { item: T; processed: boolean }>();

        for (const item of this) {
            const key = accessor(item);
            const state = seen.get(key);

            if (state === undefined) {
                // First time seeing this key. Store the item with processed: false.
                seen.set(key, { item: item, processed: false });
            } else {
                // This is a subsequent encounter (2nd, 3rd, etc.).
                if (!state.processed) {
                    // This block runs only on the second encounter for a given key.
                    if (mode === "first" || mode === "all") {
                        // Add the original item we stored earlier.
                        result.push(state.item);
                    }
                    // Mark as processed so this block doesn't run again for this key.
                    state.processed = true;
                }

                // This part runs for all subsequent encounters (2nd, 3rd, 4th...).
                if (mode === "subsequent" || mode === "all") {
                    result.push(item);
                }
            }
        }

        return result;
    }

    /**
     * Finds the median item(s) of the array based on a numeric property.
     * The median is the middle item in a sorted set.
     *
     * @param by A function to extract a number from an item for sorting.
     * @returns {ArraySL<T>} A new ArraySL containing the median item. If the array
     *   has an even number of elements, it returns the two middle items. Returns
     *   an empty array if no valid items are found.
     * @example
     * const products = new ArraySL([
     *   { name: 'A', price: 10 },
     *   { name: 'B', price: 30 },
     *   { name: 'C', price: 20 }
     * ]);
     * console.log(products.medianBy(p => p.price)); // ArraySL [{ name: 'C', price: 20 }]
     *
     * // Even number of items returns the two middle items
     * const even = products.slice(0, 2); // prices 10 and 30
     * console.log(even.medianBy(p => p.price)); // ArraySL [{ name: 'A', price: 10 }, { name: 'B', price: 30 }]
     */
    medianBy(by: (item: T) => number): ArraySL<T> {
        if (this.length === 0) {
            return new ArraySL<T>();
        }

        // Create a shallow copy to avoid mutating the original array
        const sorted = this.slice().sort((a, b) => by(a) - by(b));

        const mid = Math.floor(sorted.length / 2);

        if (sorted.length % 2 !== 0) {
            // Odd length: return the single middle item
            return new ArraySL<T>([sorted[mid]]);
        } else {
            // Even length: return the two middle items
            return new ArraySL<T>([sorted[mid - 1], sorted[mid]]);
        }
    }

    /**
     * Finds the most frequently occurring item(s) in the array (the mode).
     *
     * @param by An optional function to extract a comparable key from an item.
     * @returns {ArraySL<T>} A new ArraySL containing the most frequent item(s).
     *   Returns an empty array if there is no unique mode.
     * @example
     * const users = new ArraySL([
     *   { name: 'Alice', city: 'Paris' },
     *   { name: 'Bob', city: 'Tokyo' },
     *   { name: 'Charlie', city: 'Paris' }
     * ]);
     * console.log(users.modeBy(u => u.city)); // ArraySL [{ name: 'Alice', city: 'Paris' }, { name: 'Charlie', city: 'Paris' }]
     */
    modeBy(by: (item: T) => any = (item: T) => item): ArraySL<T> {
        if (this.length === 0) {
            return new ArraySL<T>();
        }

        const frequencies = new Map<any, number>();
        let maxFreq = 0;

        for (const item of this) {
            const key = by(item);
            const newCount = (frequencies.get(key) || 0) + 1;
            frequencies.set(key, newCount);
            if (newCount > maxFreq) {
                maxFreq = newCount;
            }
        }

        // No unique mode if all items appear with the same frequency (e.g., [1, 2, 3] or [1,1,2,2])
        if (maxFreq <= 1 && this.length > 1) {
            return new ArraySL<T>();
        }

        const modeKeys = new Set<any>();
        for (const [key, freq] of frequencies.entries()) {
            if (freq === maxFreq) {
                modeKeys.add(key);
            }
        }

        // Handle case where all items are modes (e.g., [1,1,2,2])
        if (modeKeys.size > 1 && (modeKeys.size * maxFreq) === this.length) {
            return new ArraySL<T>();
        }

        return this.filter((item) => modeKeys.has(by(item))) as ArraySL<T>;
    }
}
